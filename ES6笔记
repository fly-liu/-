let && const 相比var声明的区别：
1. let和const仅在自己的块级作用域中起作用
2. let和const不存在变量提升
3.同一块级作用域中不允许重复声明同一个变量
4.函数内不能使用let重新声明函数参数
5.let，const，class声明的全局变量不属于顶层对象的属性

const和var的区别：
1. const声明后必须立即赋值
2.声明后不可修改
3.const实际上保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于简单类型的数据（数组，字符串，布尔），值就保存在变量指向的内存地址中，等同于常量。
对于复合类型（主要是对象和数组），变量指向的内存地址保存是一个指针

ES6 声明变量的6种方法：
var，function，let，const，import，class

解构赋值：ES6允许按照一定的模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构
  
数组的解构赋值：  
  const [x,y] = [1,2]  // x=1,y=2
  默认值：
    let [foo,bar='b'] = ['a']; // foo='a',bar='b'
对象的解构赋值：
  let {bar,foo} = {foo:'aaa',bar:'bbb'};
  先找到同名的属性，再赋值给对应的变量，被赋值的是后者而不是前者
  let {foo:baz} = {foo:'aaa',bar:'bbb'};
  baz // 'aaa'
  foo // error: foo is not undefined
字符串的解构赋值：
  const [a,b,c,d,e] = 'hello';
  a // 'h'
  b // 'e'
  c // 'l'
  d // 'l'
  e // 'o'
数值和布尔值的解构赋值：如果等号右边是数值和布尔值，则会先转为对象

用途:
交换变量的值：
  let x = 1;let y = 2;
  [x,y] = [y,x];
从函数返回多个值：  
  // 返回一个数组
  function example() {
    return [1,2,3];
  }
  let [a,b,c] = example();
  // 返回一个对象
  function example() {
    return {
     foo: 1,
     bar: 2
    }
  }
  let {foo,bar} = example();
函数参数的定义：
  function f([x,y,z]) {...}
  f([1,2,3]);
  
字符串方法：
includes(),startsWith(),endsWith()
includes(): 返回布尔值，表示是否找到了参数字符串
startsWith(): 返回布尔值，表示参数字符串是否在源字符串头部
endsWith(): 返回布尔值，表示参数字符串是否在源字符串的尾部
repeat(): 返回一个新字符串，将源字符串重复n次
'x'.repeat(3); // 'xxx'
'na'.repeat(0); // ''
padStart(),padEnd(),字符串补全长度
'x'.padStart(5,'ab');  // 'ababx'
  
rest参数：形式为'...变量名'，用于获取函数的多余参数

箭头函数：
var f = () => 5;
等同于
var f = function(){return 5};

// 正常函数写法
[1,2,3].map(function(x){
  return x*x;
});
// 箭头函数写法
[1,2,3].map(x => x*x);

var result = values.sort(function(a,b){
  return a-b;
});

// 箭头函数写法
var result = values.sort((a,b) => a-b);

const numbers = (...nums) => nums;
numbers(1,2,3,4,5); // [1,2,3,4,5]

箭头函数的注意事项：
1.函数体中的this对象就是定义时所在对象，而不是使用时所在对象
2.不可以当作构造函数。也就是说，不可以使用new命令
3.不可以使用arguments对象，该对象在函数体内不存在

绑定this：绑定运算符是并排的双冒号，左边是一个对象，右边是一个函数
foo::bar;
等同于
bar.bind(foo);

foo::bar(...arguments);
等同于
bar.apply(foo,arguments);

尾调用：函数的最后一步是调用另一个函数
function f(x) {
 return g(x);
}
不属于尾调用：
function f(x) {
  g(x);
}
等同于
function f(x) {
 g(x);
 return undefined;
}
尾调用优化：只保留内层函数的调用帧。如果所有函数都是尾调用，那么可以做到每次执行时调用帧只有一项，将大大节省内存，这就是尾调用优化的意义

扩展运算符（...） ,它如同rest参数的逆运算，将一个数组转为用逗号分隔的参数序列
const [first,...rest] = [1,2,3,4,5];
first // 1
rest //[2,3,4,5]

Array.from(),将类似数组对象和可遍历对象（包含Set，Map结构）转换为数组

对象的扩展：
var foo = 'bar';
var baz = {foo};
baz // {foo:'bar'}
等同于
var baz =  {foo:foo};

function f(x,y) {
  return {x,y};
}
等同于
function f(x,y) {
 return {x:x,y:y};
}
f(1,2);  // Object {x:1,y:2}

var o = {
  method() {return 'Hello'}
}
等同于
var o = {
 method: function(){return 'Hello'}
}
Object.is();  // 比较两个值是否严格相等，与严格相等（===）不同之处是：+0不等于-0，NaN等于自身
ES5比较两个值是否相等，有两个运算符：相等运算符（==）和严格相等运算符（===）


