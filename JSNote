渐进增强
针对低版本浏览器进行构建页面，保证最基本的功能，对高版本的浏览器进行效果、交互等优化达到更好的用户体验

优雅降级
一开始构建完整的功能，再针对低版本浏览器进行兼容

sessionStorage,localStorage,cookie之间的区别
共同点：用于浏览器端存储的缓存数据
不同点：
  1.当设置了cookie后，数据会发送到服务器端，造成一定的宽带浪费；sessionStorage,localStorage会保存到本地
  2.cookie数据不能超过4KB，web Storage数据存储可以达到5M
  3.cookie只在设置的过期时间之前有效，即使关闭浏览器；sessionStorage仅在关闭浏览器之前有效；localStorage数据存储永远有效
  4.cookie和localStorage在同源同窗口中都是共享的；sessionStorage在不同的浏览器窗口不共享
  
JavaScript的typeof返回哪些数据类型?
Object,number,function,boolean,string,undefined

undefined和null的区别?
null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN.
null表示"没有对象"，即该处不应该有值。
（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。
undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。
（1）变量被声明了，但没有赋值时，就等于undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
（3）对象没有赋值的属性，该属性的值为undefined。
（4）函数没有返回值时，默认返回undefined。

强制类型转换：
parseInt(),parseFloat(),Number()

隐式类型转换：
--,+n,==

JSON对象：我们通常把JavaScript字面量对象理解成JSON对象，JSON是一种描述数据交换格式，是JavaScript的一个子集，
JSON.stringify(value [, replacer] [, space]) -- JSON序列化,将JSON对象转换为字符串
参数：
  value：要转换成JSON字符串的原始值、对象或数组
  replacer：可选参数，一个数组或函数
  space：可选参数,一个数值或一个字符串
返回：JSON格式的字符串，代表value的值，同时通过了replacer的过滤，以及根据space进行了格式化

JSON.parse(s[, reviver]) -- JSON解析，JSON反序列化，解析JSON格式的字符串
参数：
  s,要解析的字符串
  reviver,可选参数，用来转换解析值的可选函数

parseInt(),parseFloat() 和 Number() 的区别：
Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值.
parseInt()和parseFloat()方法只转换第一个无效字符之前的字符串。如“3.4.5”被转换成“3.4”,用Number()进行强制类型转换将返回NAN

匿名闭包：函数内部的代码一直存在于闭包内，在整个运行周期内，该闭包都保证了内部的代码处于私有状态。
(function(){}());  匿名函数后面的括号表示，创建一个立即执行的函数表达式

Object.prototype.hasOwnProperty() -- 判断一个对象是否包含自定义属性而不是原型链上的属性,hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数

call，apply，bind

原型链：
原型对象也是普通对象，并且也有可能有自己的原型，如果一个原型对象的原型不为null，我们就称为原型链
原型链是针对构造函数的，比如我先创建了一个函数，然后通过一个变量new了这个函数，那么这个被new出来的函数就会继承创建出来的那个函数的属性，
然后如果我访问new出来的这个函数的某个属性，但是我并没有在这个new出来的函数中定义这个变量，那么它就会往上（向创建出它的函数中）查找，这个
查找的过程就叫做原型链。

构造函数与对象之间的关系:
每一个Object都有一个__proto__ 属性，指向它的构造函数的prototype属性，构造函数也有__proto__，也就是Function.prototype,而Function.prototype的__proto__指向Object.prototype

三种函数类型：函数声明，函数表达式，构造函数

自由变量：
凡是跨了自己的作用域的变量都叫自由变量

作用域：
作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。
当定义一个函数时它的作用域也被定义了，
JavaScript中有两种作用域：全局作用域和局部作用域，ES6中let、const支持块级作用域。

作用域链：
JavaScript解释器内部的[scope]属性包含了该函数在被创建时作用域中的所有对象集合。该集合被称为函数的作用域。
当创建一个函数时，其作用域链中保存的对象，就是在创建该函数时作用域中所有可访问的数据。
作用域的特点就是，子对象会一级一级地向上寻找所有父对象的变量。

构造函数和原型链的区别：
我想这个问题，应该是想问使用构造函数继承和使用原型链继承有哪些区别。

执行上下文的概念：
执行上下文定义了一个函数的正在执行时的作用域环境。执行上下文和上下文不同，执行上下文指的是作用域，上下文指的是this的取值指向

上下文和作用域的区别：
作用域(scope) 是指变量的可访问性，上下文(context)是指 this 在同一作用域内的值。在全局作用域(scope)中上下文中始终是Window对象。(愚人码头注：取决于JavaScript 的宿主换环境，在浏览器中在全局作用域(scope)中上下文中始终是Window对象。在Node.js中在全局作用域(scope)中上下文中始终是Global 对象)

函数表达式和函数声明的区别：
函数声明以function关键字开头，接着是必须的函数（变量）名和以逗号分隔的可选的参数列表，再接着就是以大括号封装的函数体。函数声明必须是一个单独的JavaScript语句。
在任何情况下都是其它JavaScript语句的一部分（比如赋值表达式等号的右侧、函数的参数）的函数被称为函数表达式。

如何从外部读取局部变量：
在函数内部再定义一个函数。子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立

闭包的概念：
闭包就是能够读取其他函数内部变量的函数。闭包可以理解成“定义在一个函数内部的函数“。
闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。

什么是跨域：
由于浏览器的同源策略，凡是发送请求URL的协议、域名、端口号三者之间任何一个与当前页面地址不同的即为跨域。
跨域请求资源的方法有：jsonp
jsonp：通过动态插入script标签来读取其他域的资源。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行
优点：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，
     不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。
缺点：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。

json和jsonp的区别：
json是一种数据格式
jsonp是一种数据调用方式

jsonp,script标签用什么方式请求方式？
是使用get请求方式

HTTP和HTTPS的区别：
HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，
      它可以使浏览器更加高效，使网络传输减少。
HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。
HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，
于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。
HTTP 和 HTTPS 的不同之处：
HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头
HTTP 是不安全的，而 HTTPS 是安全的
HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443
在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层
HTTP 无需加密，而 HTTPS 对传输的数据进行加密
HTTP 无需证书，而 HTTPS 需要CA认证证书

HTTP协议头含有哪些重要的部分

HTTP状态码

GET和POST数据传输方式，区别：
GET和POST都是http协议定义的。

垃圾回收机制，执行环境负责管理代码执行过程中使用的内存。
垃圾回收策略：标记清除（较为常用）和引用计数

内存泄漏：指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。
内存泄漏的几种情况：
1.当页面中的元素被移除或替换时，若元素绑定的事件仍没有被移除，在IE中需要先手工移除事件，不然会造成内存泄漏

创建对象的多种方式

JavaScript中实现继承的方法：
1.原型链（prototype chaining）
2.call(),apply()
3.原型链和call()或apply()结合
4.经典继承 Object.create();

String.prototype.split()  // 把一个字符串分割成字符串数组,第一个参数必选，根据参数分割，第二个参数可选，规定数组的长度
Array.prototype.join()  // 把数组中的所有元素放入一个字符串，元素是通过指定的参数进行分隔

如何判断一个变量是Array类型？如何判断一个变量是Number类型？

Object是引用类型嘛？引用类型和基本类型有什么区别？哪个是存在堆哪一个是存在栈上面的？

解释一下事件冒泡和事件捕获

事件委托（手写例子），事件冒泡和捕获，如何阻止冒泡？如何组织默认事件？

new 一个对象具体做了什么

=== 和 == , [] === [], undefined === undefined,[] == [], undefined == undefined

'use strict' 严格模式的好处和坏处

JS如何实现重载和多态

如何实现图片滚动懒加载

setTimeout和promise的执行顺序

navigator对象，location和history

js动画和css3动画比较

DOM事件的绑定的几种方式

DOM事件中target和currentTarget的区别

手指点击可以触控的屏幕时，是什么事件

什么是函数柯里化，以及在函数式编程的应用

JS代码调试

浏览器的全局变量有哪些

浏览器同一时间能够从一个域名下载多少资源

什么是预加载、懒加载
