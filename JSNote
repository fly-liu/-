JSON对象：我们通常把JavaScript字面量对象理解成JSON对象，JSON是一种描述数据交换格式，是JavaScript的一个子集，
JSON.stringify(value [, replacer] [, space]) -- JSON序列化,将JSON对象转换为字符串
参数：
  value：要转换成JSON字符串的原始值、对象或数组
  replacer：可选参数，一个数组或函数
  space：可选参数,一个数值或一个字符串
返回：JSON格式的字符串，代表value的值，同时通过了replacer的过滤，以及根据space进行了格式化

JSON.parse(s[, reviver]) -- JSON解析，JSON反序列化，解析JSON格式的字符串
参数：
  s,要解析的字符串
  reviver,可选参数，用来转换解析值的可选函数

parseInt() 和 Number() 的区别：

匿名闭包：函数内部的代码一直存在于闭包内，在整个运行周期内，该闭包都保证了内部的代码处于私有状态。
(function(){}());  匿名函数后面的括号表示，创建一个立即执行的函数表达式

Object.prototype.hasOwnProperty() -- 判断一个对象是否包含自定义属性而不是原型链上的属性,hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数

原型链：
原型对象也是普通对象，并且也有可能有自己的原型，如果一个原型对象的原型不为null，我们就称为原型链
原型链是针对构造函数的，比如我先创建了一个函数，然后通过一个变量new了这个函数，那么这个被new出来的函数就会继承创建出来的那个函数的属性，
然后如果我访问new出来的这个函数的某个属性，但是我并没有在这个new出来的函数中定义这个变量，那么它就会往上（向创建出它的函数中）查找，这个
查找的过程就叫做原型链。

构造函数与对象之间的关系:
每一个Object都有一个__proto__ 属性，指向它的构造函数的prototype属性，构造函数也有__proto__，也就是Function.prototype,而Function.prototype的__proto__指向Object.prototype

三种函数类型：函数声明，函数表达式，构造函数

自由变量：
凡是跨了自己的作用域的变量都叫自由变量

作用域：
作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。
当定义一个函数时它的作用域也被定义了，
JavaScript中有两种作用域：全局作用域和局部作用域，ES6中let、const支持块级作用域。

作用域链：
JavaScript解释器内部的[scope]属性包含了该函数在被创建时作用域中的所有对象集合。该集合被称为函数的作用域。
当创建一个函数时，其作用域链中保存的对象，就是在创建该函数时作用域中所有可访问的数据。
作用域的特点就是，先在自己的变量范围中查找，如果找不到，就会沿着作用域往上找，这个查找的过程就叫作用域链

执行上下文的概念：
执行上下文定义了一个函数的正在执行时的作用域环境。执行上下文和上下文不同，执行上下文指的是作用域，上下文指的是this的取值指向

上下文和作用域的区别：
作用域(scope) 是指变量的可访问性，上下文(context)是指 this 在同一作用域内的值。在全局作用域(scope)中上下文中始终是Window对象。(愚人码头注：取决于JavaScript 的宿主换环境，在浏览器中在全局作用域(scope)中上下文中始终是Window对象。在Node.js中在全局作用域(scope)中上下文中始终是Global 对象)

函数表达式和函数声明的区别：

闭包的概念：
闭包就是能够读取其他函数内部变量的函数。闭包可以理解成“定义在一个函数内部的函数“。
1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
2.在代码中引用自由变量。（自由变量：在函数中访问全局变量就相当于是在访问自由变量）



