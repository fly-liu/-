Array.prototype.slice.call 可以将伪数组转化为真正的数组
var obj = {
  0 : 'a',
  1 : 'b',
  2 : 'c',
  length : 3
}
Array.prototype.slice.call(obj);  // ["a", "b", "c"]
先将传入的第一个参数转换为数组，再调用slice

slice 有两个用法，一个是String.slice;一个是Array.slice；第一个返回的是字符串，第二个返回的是数组
Array.slice(start,end) 可以从已有的数组中返回选定的元素

apply && call --
apply和call都是为了改变某个函数运行时的上下文而存在的（改变函数内部的this指向）
调用apply或call方法this指向第一个参数，apply的第二个参数是一个数组，call从第二参数到后面的所有参数都是数组的里面的元素
var numbers = [5, 458 , 120 , -215];
var maxInNumbers = Math.max.apply(Math,nubers); // 458
var minInNumbers = Math.min.call(Math,5, 458 , 120 , -215); // -215

验证是否是数组：
function isArray(obj) {
  return Object.prototype.toString.call(obj);  // [Object Array]
}

bind --改变函数体内的this指向
bind会创建一个新函数，称为绑定函数，当调用这个函数的时候，绑定函数会以创建它时传入bind（）方法的第一个参数作为this，传入bind()方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数;

bind与apply、call最大的区别就是：bind不会立即调用，其他两个会立即调用

/*
* * 原型 和 闭包
*/
判断一个变量是不是对象，值类型的类型判断用 typeof，引用类型的类型判断用 instanceof
JavaScript中 一切(引用类型)都是对象，对象是属性的集合

继承 -- JavaScript的继承是通过原型链实现的
访问一个属性时，先在基本属性中查找，如果没有再沿着原型往上找，这就是原型链
区分一个属性是基本属性还是从原型上继承的，使用 hasOwnProperty()
所有对象的原型链都会找到Object.prototype,因此所有对象都有Object.prototype的方法

JavaScript 执行上下文 --
JavaScript的运行环境有三种：
  全局级别的代码，这是默认的代码运行环境，一旦代码被载入，引擎最先进入这个环境
  函数级别的代码，当执行一个函数，运行函数中的代码
  Eval 内的代码，在eval()函数中运行的代码

javascript是一个单线程语言，这意味着在浏览器中同时只能做一件事情。当javascript解释器初始执行代码，它首先默认进入全局上下文。每次调用一个函数将会创建一个新的执行上下文。
每当调用一个函数时，一个新的执行上下文就会被创建出来。然而，在javascript引擎内部，这个上下文的创建过程具体分为两个阶段:
1. 建立阶段(发生在当调用一个函数时，但是在执行函数体内的具体代码以前)
   建立变量，函数，arguments对象，参数
   建立作用域链
   确定this的值
   
2. 代码执行阶段:
   变量赋值，函数引用，执行其它代码
   
执行全局代码时，会产生一个上下文环境，每次调用函数又会产生执行上下文环境。当函数调用完时，这个上下文环境以及其中的数据都会被清除，再重新回到全局上下文环境中。
处于活动状态的上下文环境只有一个。

this -- 在函数中this取值，是在函数真正被调用执行时确定的，函数定义的时候确定不了
this取值分为4种情况：
1. 构造函数，所谓构造函数就是用来new对象的函数，严格来说，所以的函数都可以new一个对象
如果函数作为构造函数用，this表示new出来的对象

2. 函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数的this指向该对象

3. 函数用call或apply调用
当一个函数被call或apply调用时，this的值就取传入的对象的值

4.全局环境下 & 普通函数调用时，this指向window对象

补充：在整个作用域链中，this代表的是当前对象的值

作用域在函数定义时就已经确定了。而不是在函数调用时确定。
作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。
所以，如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。

自由变量 -- 在当前作用中使用的变量是在其他作用域中声明的，对于当前作用域来说，这个变量就是自由变量
静态作用域 -- 要到创建这个函数的作用中取值，这就是所谓的静态作用域

闭包 -- 应用闭包的两种情况，函数作为返回值，函数作为参数传递


